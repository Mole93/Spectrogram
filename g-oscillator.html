<link rel="import" href="./bower_components/polymer/polymer.html">
<link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

<polymer-element name="g-oscillator" attributes="log speed resolutionMax resolutionMin square, scale">
  <template>
  <style>
    canvas {
      position: absolute;
      width: 100%;
      height: 100%;
    }
  </style>
  <canvas id="freq"
      on-mousedown={{onMouseDown}}
      on-mouseup={{onMouseUp}}
      on-mousemove={{onMouseMove}}
      on-mouseout={{onMouseOut}}
      on-touchstart={{onTouchStart}}
      on-touchend={{onTouchEnd}}
      on-touchmove={{onTouchMove}}></canvas>
  </template>
  <script>
    // Assumes context is an AudioContext defined outside of this class.
    Polymer('g-oscillator', {
      gainAmount: 0.2,
      history: [],
      log: false,
      speed: 2,

      fadeTime: 0.01,
      resolutionMax: 20000,
      resolutionMin: 10,
      square: false,
      scale: false,
      scaleVal: [16.35, 18.35, 20.60, 21.83, 24.50, 27.50, 30.87],
      scaleNames: ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'C'],
      textLabel: 'C 0',

      attachedCallback: function() {
        this.loop();
      },

      loop: function() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;

        this.addHistory(this.lastY);
        var canvas = this.$.freq;
        var ctx = canvas.getContext('2d');
        canvas.width = this.width;
        canvas.height = this.height;

        var size = 6;
        var nyquist = context.sampleRate / 2;

        for (var i = 0; i < this.history.length; i++) {
          var y = this.history[i];

          if (y === null) {
            continue;
          }
          var x = this.width - (this.history.length - i - 1) * this.speed;
          // TODO(smus): Elimiate fudge factor.



          ctx.fillStyle = 'red';
          ctx.fillRect(x - size / 2, y - size / 2, size, size);
        }

        if (this.osc_) {
          // Label the point.
          var label = this.formatFrequency_(this.lastFreq);
          if(this.scale){
            label = this.textLabel;
          }
          ctx.font = '20px Inconsolata';
          ctx.fillStyle = 'white'
          ctx.fillText(label, this.lastX, this.lastY);
        }
        requestAnimationFrame(this.loop.bind(this));
      },

      formatFrequency_: function(freq) {
        return Math.round(freq) + ' Hz';
      },

      onMouseDown: function(event) {
        // console.log('md');
        if (this.osc_) {
          // There can be only one oscillator.
          return;
        }
        this.updatePointer(event);
        // Create an oscillator.
        this.osc_ = this.createOscillator_("1");
        this.lastFreq = this.getLastFrequency();
        this.osc_.frequency.value = this.lastFreq;
        if (this.square) {
          if (this.osc2_) {
            return;
          }
          this.osc2_ = this.createOscillator_("2");
          this.osc2_.frequency.value = this.lastFreq * 3;

          this.osc3_ = this.createOscillator_("3");
          this.osc3_.frequency.value = this.lastFreq * 5;

          this.osc4_ = this.createOscillator_("4");
          this.osc4_.frequency.value = this.lastFreq * 7;

          this.osc5_ = this.createOscillator_("5");
          this.osc5_.frequency.value = this.lastFreq * 9;

          this.osc6_ = this.createOscillator_("6");
          this.osc6_.frequency.value = this.lastFreq * 11;
        }
      },

      onMouseUp: function() {
        // console.log('mu');
        this.deleteOscillator_();
        this.updatePointer(null);
        this.lastFreq = null;
      },

      onMouseMove: function(event) {
        // console.log('mm');
        if (this.osc_) {
          this.updatePointer(event);
          this.lastFreq = this.getLastFrequency();
          this.osc_.frequency.value = this.lastFreq;
          if (this.square) {
            if (this.osc2_) {
              this.updatePointer(event);
              this.osc2_.frequency.value = this.lastFreq * 3;
              this.osc3_.frequency.value = this.lastFreq * 5;
              this.osc4_.frequency.value = this.lastFreq * 7;
              this.osc5_.frequency.value = this.lastFreq * 9;
              this.osc6_.frequency.value = this.lastFreq * 11;
            }

          }
        }
      },

      onMouseOut: function(event) {
        // console.log('mo');
        this.deleteOscillator_();
        this.updatePointer(null);
        this.lastFreq = null;
      },

      onTouchStart: function(event) {
        event.preventDefault();
        // console.log('ts');
        if (this.osc_) {
          return;
        }
        this.updatePointer(event);
        // Create an oscillator.
        this.osc_ = this.createOscillator_();
        this.lastFreq = this.getLastFrequency();
        this.osc_.frequency.value = this.lastFreq;
      },

      onTouchMove: function(event) {
        event.preventDefault();
        // console.log('tm');
        if (this.osc_) {
          this.updatePointer(event);
          this.lastFreq = this.getLastFrequency();
          this.osc_.frequency.value = this.lastFreq;
        }
      },

      onTouchEnd: function(event) {
        event.preventDefault();
        // console.log('te');
        this.updatePointer(null);
        this.deleteOscillator_();
        this.lastFreq = null;
      },

      updatePointer: function(event) {
        event = event || {};
        var type = event.type || '';
        if (type.indexOf('mouse') == 0) {
          this.lastX = event.pageX;
          this.lastY = event.pageY;
          // console.log("LASt Y: "+this.lastY);
        } else if (type.indexOf('touch') == 0) {
          this.lastX = event.touches[0].pageX;
          this.lastY = event.touches[0].pageY;
        } else {
          this.lastX = null;
          this.lastY = null;
        }
      },

      addHistory: function(freq) {
        if (this.history.length > 100) {
          this.history.splice(0, 1);
        }
        this.history.push(freq);
      },

      getLastFrequency: function() {
        var x = this.lastX;
        var y = this.lastY;

        var percent = 1 - (y / this.height);
        var nyquist = context.sampleRate / 2;
        if (this.log) {
          percent = this.logScale_(percent * 1000, 1000) / 1000;
        }
        var freq = Math.floor(percent * (this.resolutionMax - Number(this.resolutionMin)) + Number(this.resolutionMin)) + 1;
        if (this.scale) {

          var dist = 20000;
          var note = 0;
          var name = this.scaleNames[0];
          var harmonic = 0;
          for (var j = 1; j < 1500; j=j*2) {

            for (var k = 0; k < this.scaleVal.length; k++) {

              var check = j * this.scaleVal[k];
              var checkDist = Math.abs(freq - check);
              if (checkDist < dist) {
                dist = checkDist;
                note = check;
                name = this.scaleNames[k];
                harmonic = Math.round(Math.log2(j)-1);
              }
            }
          }
          freq = note;
          this.textLabel = name+ ' '+harmonic;
        }


        return freq;
      },

      createOscillator_: function(num) {
        // Create a gain node.
        var gain = context.createGain();
        var harmonicMultiplier = 1;
        gain.gain.value = 0;
        gain.connect(context.destination);
        // TODO(smus): Clean this up!
        switch (num) {
          case "1":
            this.gain1_ = gain;
            harmonicMultiplier = 1;
          case "2":
            this.gain2_ = gain;
            harmonicMultiplier = 0.333;
          case "3":
            this.gain3_ = gain;
            harmonicMultiplier = 0.2;
          case "4":
            this.gain4_ = gain;
            harmonicMultiplier = 0.143;
          case "5":
            this.gain5_ = gain;
            harmonicMultiplier = 0.111;
          case "6":
            this.gain6_ = gain;
            harmonicMultiplier = 0.09;

            break;
          default:

        }
        //   this.gain_ = gain;
        // console.log(this.gain_+num);
        // Create an oscillator and connect it through the gain.
        var osc = context.createOscillator();
        osc.connect(gain);

        // Start it with a fade-in.
        gain.gain.linearRampToValueAtTime(this.gainAmount * harmonicMultiplier,
          context.currentTime + this.fadeTime);
        osc.start(0);
        return osc;
      },

      deleteOscillator_: function() {
        if (this.osc_) {
          var endTime = context.currentTime + this.fadeTime;
          this.gain1_.gain.linearRampToValueAtTime(0, endTime);
          this.osc_.stop(endTime);
          this.osc_ = null;
          if (this.square) {
            if (this.osc2_) {
              this.gain2_.gain.linearRampToValueAtTime(0, endTime);
              this.osc2_.stop(endTime);
              this.osc2_ = null;

              this.gain3_.gain.linearRampToValueAtTime(0, endTime);
              this.osc3_.stop(endTime);
              this.osc3_ = null;

              this.gain4_.gain.linearRampToValueAtTime(0, endTime);
              this.osc4_.stop(endTime);
              this.osc4_ = null;

              this.gain5_.gain.linearRampToValueAtTime(0, endTime);
              this.osc5_.stop(endTime);
              this.osc5_ = null;

              this.gain6_.gain.linearRampToValueAtTime(0, endTime);
              this.osc6_.stop(endTime);
              this.osc6_ = null;

            }
          }
        }
      },

      /**
       * Given an index and the total number of entries, return the
       * log-scaled value.
       */
      logScale_: function(index, total, opt_base) {
        var base = opt_base || 2;
        var logmax = this.logBase(total + 1, base);
        var exp = logmax * index / total;
        return Math.pow(base, exp) - 1;
      },

      logBase: function(val, base) {
        return Math.log(val) / Math.log(base);
      },
    });
  </script>
</polymer-element>
